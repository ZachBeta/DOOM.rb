{
  "version": 1,
  "rules": [
    {
      "name": "Ruby Style Guide",
      "description": "Follow Sandi Metz's POODR principles for Ruby code",
      "patterns": [
        {
          "pattern": "\\.rb$",
          "instructions": "Write Ruby code following Practical Object-Oriented Design principles by Sandi Metz. Focus on single responsibility, dependency injection, and composition over inheritance. Keep classes small and focused with clear public interfaces."
        }
      ]
    },
    {
      "name": "Minimal Token Usage",
      "description": "Keep explanations concise to save tokens",
      "patterns": [
        {
          "pattern": ".*",
          "instructions": "Keep explanations and follow-up questions to a minimum to save tokens. Focus on delivering working code with just enough context."
        }
      ]
    },
    {
      "name": "Test-Driven Development",
      "description": "Encourage TDD practices",
      "patterns": [
        {
          "pattern": "_test\\.rb$",
          "instructions": "Write Minitest tests that focus on behavior rather than implementation details. Follow the Arrange-Act-Assert pattern. Ensure tests are isolated and don't depend on each other."
        }
      ]
    },
    {
      "name": "Documentation",
      "description": "Document code appropriately",
      "patterns": [
        {
          "pattern": "\\.rb$|\\.md$",
          "instructions": "Document public interfaces clearly but avoid excessive comments in implementation code. Let well-named methods and variables speak for themselves."
        }
      ]
    },
    {
      "name": "Game Architecture",
      "description": "Maintain clean game architecture",
      "patterns": [
        {
          "pattern": "lib/doom/.*\\.rb$",
          "instructions": "Maintain separation of concerns between game components. Keep rendering logic separate from game logic. Use composition over inheritance. Follow the Single Responsibility Principle. Prefer small, focused classes with clear public interfaces."
        }
      ]
    },
    {
      "name": "Performance Considerations",
      "description": "Keep performance in mind for game code",
      "patterns": [
        {
          "pattern": "renderer\\.rb$|ray.*\\.rb$",
          "instructions": "Be mindful of performance in rendering and physics code. Avoid unnecessary object creation in tight loops. Consider using memoization or caching for expensive calculations. Use profiling to identify bottlenecks."
        }
      ]
    },
    {
      "name": "Logging Best Practices",
      "description": "Use logging effectively",
      "patterns": [
        {
          "pattern": "logger\\.rb$|.*\\.rb$",
          "instructions": "Use appropriate log levels (debug, info, warn, error). Keep logs informative but not too verbose to avoid context window bloat. Log important state changes and errors, but avoid logging in tight loops."
        }
      ]
    },
    {
      "name": "Collision Detection",
      "description": "Guidelines for implementing collision detection",
      "patterns": [
        {
          "pattern": "player\\.rb$|movement\\.rb$|collision.*\\.rb$",
          "instructions": "Implement collision detection using simple geometric calculations. Consider using a grid-based approach for efficiency. Separate collision detection logic from movement logic."
        }
      ]
    },
    {
      "name": "Texture Mapping",
      "description": "Guidelines for implementing texture mapping",
      "patterns": [
        {
          "pattern": "renderer\\.rb$|texture.*\\.rb$|wall.*\\.rb$",
          "instructions": "Implement texture mapping by calculating texture coordinates based on wall hit positions. Use efficient texture lookup methods. Consider caching textures for performance."
        }
      ]
    },
    {
      "name": "WAD File Parsing",
      "description": "Guidelines for implementing WAD file parsing",
      "patterns": [
        {
          "pattern": "wad.*\\.rb$|parser.*\\.rb$",
          "instructions": "Implement WAD file parsing using a clean, modular approach. Separate concerns between file I/O, data structure parsing, and game object creation. Use streaming approaches for large files."
        }
      ]
    }
  ]
} 